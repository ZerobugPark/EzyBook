#✈️ 간편한 예약으로 액티비티를 더 가까이 EzyBook
![ReadMeTitle](https://github.com/user-attachments/assets/5f81374c-e918-4aaf-ac9e-de722f5479e4)
<br><br><br>


## 프로젝트 소개
"EzyBook"은 Easy(쉬운)와 Book(예약)의 합성어로, 누구나 쉽고 간편하게 액티비티를 예약할 수 있는 서비스입니다.  
국내외 다양한 액티비티를 조회하고, PG 결제를 통해 안전하게 예약할 수 있으며,  
커뮤니티와 채팅 기능을 통해 판매자와 실시간으로 소통하거나 예약 후기를 확인할 수 있습니다.  
또한 사용자가 직접 다녀온 액티비티에 대한 리뷰 작성도 가능합니다.


### 주요 기능
#### 1. 회원 및 인증(JWT)
- 소셜/이메일 로그인: 카카오톡, 애플, 이메일 회원 가입/로그인
- 자동 로그인: 앱 재실행 시 자동 로그인 유지

#### 2. 액티비티 탐색 및 예약
- 국내외 액티비티 조회 (카테고리별 / 국가별 필터링 가능)
- 예약 및 결제: PG 연동을 통한 안전한 결제 시스템

#### 3. 소통 및 후기
- 실시간 채팅: Socket 기반의 호스트-유저 간 1:1 채팅
- 리뷰 기능: 이용 후 텍스트 및 이미지 리뷰 작성 가능
- 커뮤니티: ~~

#### 4. 네트워크 최적화 (Etag 기반)

#### 5. 이미지 로딩 최적화를 위한 캐시 처리 (Memory & Disk Cache)

<br><br>

## 프로젝트 정보
기획 및 개발: 2025.05.12 ~ 2025.07.12(약 2달간)  
유지보수 및 기능 업데이트: 2025.07.13 ~  

<br>

### 기술 스택
- **FrameWork** - SwfitUI, Combine
- **Library** - KakaoSDK, Realm, iamport_ios, SocketIO, Alamofire, Firebase
- **Architecture** - CleanArchitecture + MVVM + Coordinator(Navigation Stack based)  

<br><br>

### 기술 설명
- **최소 지원 iOS 버전**: iOS 16.0
- **Local DB**: Realm

<br><br>

## 아키텍쳐 기준과 브랜치 전략

### 아키텍쳐 선정 기준
이번 프로젝트에서는 MVVM 아키텍처와 Coordinator 패턴을 적용했습니다. 빠르게 만들기만 하는 구조보다는, 출시 이후에도 유지보수가 쉽고 확장 가능한 구조를 목표로 했습니다.  
View는 화면 표시만 담당하고, 화면 전환은 Coordinator가, 로직 처리는 ViewModel이 담당하도록 역할을 분리했습니다.  
현재는 View에서 Coordinator를 참조하고 있지만, 다음 프로젝트에서는 ViewModel이 이벤트만 전달하고, Coordinator가 구독해서 처리하는 구조를 시도해볼 계획입니다.

### Realm 
Core Data는 Apple에서 제공하는 퍼스트 파티 프레임워크로, 데이터 변경 사항 추적 기능과 다양한 기능을 제공하지만,  
초기 설정이 복잡하고 러닝커브가 높은 편입니다. 반면 Realm은 상대적으로 빠르게 적용할 수 있으며, 데이터 변경 사항 추적도 간단하게 구현할 수 있습니다.  
특히 Realm은 자체 경량 엔진과 메모리 매핑 기반 구조 덕분에, Core Data보다 더 빠른 성능을 보여줄 수 있어 **짧은 기간 내 앱 개발이 필요한 상황에서 더 적합한 선택**이라고 판단했습니다.


### RxSwfit 
UIKit 기반 앱을 리액티브하게 설계하기 위해 RxSwift를 선택했습니다. Combine은 SwiftUI와 함께할 때 강력한 퍼스트 파티 프레임워크이지만,  
UIKit에서는 UI 이벤트 연동이 번거롭고, 실무 사례도 적은 편이라 RxCocoa를 활용한 RxSwift가 더 적합하다고 판단했습니다.

### API 호출 최적화 전략
Google Sheet API를 사용하면서, API 호출 수 제한에 대한 고민이 있었습니다.  
클라이밍장 데이터는 자주 바뀌지 않는 특성이 있어, 앱 실행 시 1회만 서버에서 데이터를 받아오고, 이후에는 공통 데이터(ShareData)로 보관한 뒤,  
각 ViewModel에 주입하는 구조로 설계했습니다. 이 방식을 통해 반복 호출을 줄이고, UX 성능도 확보할 수 있었습니다. 추후 사용자 수나 데이터량이 늘어나면,  
주기적 동기화(예: 주 1회) 방식으로 확장할 계획입니다.

### 브랜치 전략
- Git Flow 전략을 기반으로 main, develop, feature 브랜치를 운영했습니다.
  - **main:** 배포 가능한 브랜치로, 언제든 배포 가능한 상태로 관리합니다.
  - **develop:** 새로운 기능 개발 및 버그 수정 등 모든 개발 작업을 포함합니다.
  - **feature:** 새로운 기능을 개발을 위한 브랜치로 develop에서 분기되며, 기능 개발이 완료되면 develop 브랜치로 병합합니다.

<br><br>

## 페이지별 기능

### [온보딩 및 회원가입]

- 앱 실행시 **온보딩 화면**이 나오며 다음 페이지로 이동됩니다.  
  - ✅ 회원가입이 완료된 경우 → **메인 화면**으로 이동
  - ❌ 회원가입이 안 된 경우 → **회원가입 화면**으로 이동
- 회원가입은 **닉네임만 필수 항목**이며, 다음 조건을 만족해야 합니다:
  - 공백을 제외한 **2~7자** 사이의 문자열

| 온보딩 및 회원가입 |
|:--------:|
| <img src="https://github.com/user-attachments/assets/59790eec-d299-45fd-911d-6caf8bf3b16c" width="350"/> | 
 
<br><br>

### [홈, 캘린더, 기록 등록]

- 홈 화면에서는 이번 달 **월간 클라이밍 기록**과  **가장 많이 방문한 클라이밍장**이 표시됩니다.
- 기록 등록 시에는 날짜, 클라이밍장, 운동 시간이 저장되며, 클라이밍장을 선택하면 **난이도 선택 화면**으로 이동합니다.
- 캘린더 화면에서는 다음과 같이 마커가 표시됩니다:
  - **현재 날짜**: 푸른색 마커
  - **기록이 있는 날짜**: 붉은색 마커  
  - **현재 날짜에 기록도 존재할 경우**: 푸른색 마커가 우선 적용됩니다
- 동일 날짜에 **2개 이상의 기록이 있는 경우**, **등록된 순서대로** 리스트에 표시됩니다.


| 홈, 캘린더, 기록 등록 |
|:--------:|
| <img src="https://github.com/user-attachments/assets/cdb15288-059a-48f4-9a39-b766c612edab" width="350"/> |

<br><br>

### [실시간 기록]

- **실시간 기록**은 클라이밍장을 선택한 후 시작되며, 이 시점부터 **타이머가 1초 단위로 작동**합니다.
- **원하지 않는 난이도는 스와이프 동작을 통해 숨길 수 있으며**, 이후 언제든지 다시 불러올 수 있습니다.
- 운동이 종료되면 기록에 대한 요약 화면이 표시됩니다.

| 실시간 기록 |
|:--------:|
| <img src="https://github.com/user-attachments/assets/e5703bb9-e724-414e-a4ef-5557ff7ee564" width="350"/> |

<br><br>

### [검색]

- **클라이밍장 검색**은 검색 버튼을 눌렀을 때 실행되며, 앱 실행 시 서버로부터 받은 데이터를 기반으로 로컬에 저장된 정보를 조회합니다.  
- 각 클라이밍장 상세 페이지에는 **장소 설명**, **주소**, **Instagram ID** 등이 포함되어 있으며, Instagram ID를 클릭하면 해당 계정으로 이동합니다.
- **정보 수정 요청하기** 버튼을 누르면, ALLEX 공식 Instagram 계정으로 이동됩니다.  
 
| 검색 |
|:--------:|
| <img src="https://github.com/user-attachments/assets/e7f88c1d-7222-48dc-8595-f3c85144f8a2" width="350"/> |

<br><br>














